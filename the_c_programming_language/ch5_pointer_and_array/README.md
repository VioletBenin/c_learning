# 第五章 指针与数组

## 5.1 指针与地址
机器有一系列连续编号或编址单元,这些存储单元可以单个进行操纵,也可以连续成组的方式进行操纵.通常情况下,机器的一个字节可以存放一个char类型数据,两个相邻字节可以存放一个short类型数据,4个相邻字节可以存放一个long类型数据.指针能够存放一个地址或者一组存储单元(通常是2个或4个字节).

一元运算符`&`可用于取一个对象的地址,因此,下列语句:
```cpp
p = &c
```
将把c的地址赋给p,称p为指向p的指针. 地址运算符只用于内存中的对象,即变量与数组元素, 它不能作用于表达式,常量或者`register`类型的变量.

一元运算符`*`是间接寻址或间接引用运算符当它作用于指针时,将访问指针所指的对象.

一元运算符`*`与`&`的优先级比算数运算优先级高,因此,赋值语句:
```cpp
*p += 1
```
将*p的对象的值取出并+1,它等同于
```cpp
++*p
// 或者
(* p)++
```
语句`*(p)++`括号必不可少,否则表达式会对p加一而不是指向的对象

## 5.2 指针与函数参数
由于C中是以传值得方式将参数传给调用函数,因此,被调用的函数不能直接修改主函数中变量的值.例如,函数定义为以下形式:
```cpp
void swap(int x, int y) {
  int temp;

  temp = x;
  x = y;
  y = temp;
}
```
则下列语句无法达到目的
```cpp
swap(a, b);
```
这是因为上述函数不会影响到调用它的例程中参数a,b的值,仅仅交换了副本的值;

实现目标可以使主调程序指向所要交换的变量的指针传递给被调用函数,即
```cpp
swap(&a, &b);
```
由于一元运算符`&`用来取地址,这样`&a`就是一个指向变量a的指针.`swap`函数所有参数声明为指针,并且通过指针间接访问他们的操作数.
```cpp
void swap(int *px, int *py) {
  int temp;

  temp = * px;
  * px = * py;
  * py = temp;
}
```

来看这样一个例子:

函数getint接受自由格式的输入,并执行转换,将输入的字符流分解成整数,每次调用得到一个整数.getint返回得到的整数,并且,在到达输入结尾时要返回文件结束的标记.这些值必须通过不同方式返回.EOF可以用任何值表示,也可以用一个输入值表示
