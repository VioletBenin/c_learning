# 第四章 函数与程序结构

## 4.1 函数的基本知识
最简单的函数如图
```
dunny(){}
```
它不执行操作也没有返回值,可以在开发时候保留位置利于以后填充.
若函数省略了返回值类型,则默认为int型.

程序可以看作变量定义与函数定义的集合.函数之间的通信可以通过参数,函数返回值以及外部变量进行.函数在源文件中出现的次序是任意的.只要保证每一个函数不被分离到多个文件中,源程序就可以分为多个文件.

被调用函数通过return语句向调用者返回值
```c
return 表达式
```
必要时,表达式将被转换为返回值的类型.表达式通常加一对圆括号,此处括号是可选的.

调用函数可以忽略返回值,return后面也不一定需要表达式.return后面没有表达式时,函数不会向调用者返回值.当被调用的函数执行到最右边的花括号时而结束执行时,控制同样会返回给调用者(不返回值).如果某个函数从一个地方返回有返回值,而从另一个地方没有返回值,该函数不非法,但可能是一种文体的征兆.

## 4.2 返回非整型值得函数
- [string_to_double.cpp 字符串转为浮点数](./string_to_double.cpp)
标准库中包含类似atof函数,在头文件`<stdlib.h>`中声明.
- [calculator 简单计算器](calculator.cpp)
```cpp
double sum,atof(char[])
```
函数声明与定义类型必须一致. 如果atof函数与调用它的主函数在同一源文件中,类型不一致,编译器会监测出错误. 但如果是单独编译,不匹配错误不会被检测出来,结果毫无意义.

如果先前没有声明的一个名字出现在表达式中,并且其后紧跟一个左圆括号,那么上下文会认为这是一个函数名字,该函数的返回值被假定为int,但上下文不对参数做任何假设. 并且,如果函数声明不含参数,如:
```cpp
double atof()
```
那么编译程序不会对atof的参数做任何假设, 并会关闭所有参数检查. 对空参数表的这种特殊处理是为了使新的编译器能编译比较古老的c语言程序.不过这是不提倡的,如果带有参数,则要声明他们,如果没有参数,用`void`进行声明.

```cpp
int atoi(char s[]){
  double atof(char s[]);

  return (int) atof(s);
}
```

其中,表达式的值在返回之前被转换为函数类型. 因为函数atoi返回值为int,所以return语句中atof函数的double将被自动转化为int. 但是这种操作可能会丢失信息,某些编译器会给出警告,在这里进行显式转换,可以避免相关警告信息.

## 4.3 外部变量
C语言程序可以看作由一系列外部对象组构成,这些外部对象可以是变量或者函数.internal 用于描述定义在函数内部的函数及变量. 外部变量定义在函数之外,因此可以在许多函数中使用.C语言不允许在一个函数中定义其他函数,因此函数本身是外部的. 默认情况下,外部变量函数有下列性质:
通过一个名字对外部变量的所有引用(即这种引用来自单独编译的不同函数)实际上都是引用的同一对象(标准中把这一性质成为 *外部链接*)

因为外部变量可以在全局内访问,这就为函数之间的数据交换提供了一种可以代替函数参数与返回值的方式. 任何函数都可以通过名字访问同一个外部变量,当然这个变量需要某种方式进行声明.

如果函数之间要共享大量变量,使用外部变量比使用一个很长的参数表方便,但是,这样做必须非常谨慎,因为这种方式可能对程序结构产生不良影响,而且很可能导致各个函数之间有太多数据联系.

外部变量的用途还表现在他们与内部变量相比有更大的作用域和更长的生存期. 自动变量只能在函数的内部使用, 从其所在的函数被调用时变量开始存在, 在函数退出时变量也消失. 外部变量是永远存在的, 他们的值在一次函数调用到下一次函数调用之间保持不变. 因此,如果两个函数必须共享某些数据,而两个函数有不调用对方,这种情况下最方便的方式是将共享数据设为外部变量.

下面通过例子说明这一点
目标是编写一个具有加减乘除运算的计算器程序,为了容易实现,我们用逆波兰表示法(Reverse Polish notation，RPN，或逆波兰记法)来代替中缀表示法.

逆波兰表示法中,所有运算符都在操作数的后面
```
(1-2) * (4+5)
1 2 - 4 5 + *
```
逆波兰表示法中没有括号,只要知道每个运算符需要几个操作数就不会引起歧义.

实现:
每个操作数都被压入栈中;一个运算符到达后,从中弹出相应项目的操作数,然后把该运算符作用于弹出的操作数,并把结果压入栈中.例如上面先把1,2压入栈,然后用两者之差-1取代他们; 然后4,5压入栈中,用9取代他们, 最后取出栈顶的-1,9,把他们的积-9压入栈顶
```cpp
while (下一个是运算符或操作数不是EOF) {
  if (是数) {
    将数压到栈中
  } else if (是运算符) {
    弹出所需数目的操作数
  } else if(是换行符){
    弹出并打印栈顶的值
  }else{
    出错
  }
}
```
main不需要了解控制栈的变量信息,所以可以作为外部变量
- [RPN_calculator 逆波兰计算器](./RPN_calculator.cpp)

## 4.4 作用域原则
构成C语言程序的函数与外部变量可以分开进行编译. 一个程序可以存放在几个文件中,原先已编译过的函数可以从库中进行加载.

名字的 *作用域* 指的是程序中可以使用该名字的部分.对于函数开头声明的自动变量,其作用域是声明该变量名的函数. 不同函数中声明具有相同名字的各个局部变量之间没有任何关系. 函数的参数也是这样,实际上可以看成局部变量.

外部变量或函数的作用域从声明它的地方开始,到其所在的(等待编译)文件的末尾结束..
```cpp

main(){}

int sp = 0;
double val[MAXVAL];

void push(double f){}

double pop(void){}
```
例如,`push`不需要任何声明就可以通过名字访问变量`sp`,`val`但是变量名不能用在主函数`main`中.

另一方面,如果在外部变量声明之前使用该变量, 或者外部变量的定义与使用不在同一源文件中,则必须在相应的变量声明中强制使用关键字`extern`

将外部变量的 *声明* 和 *定义* 严格区分开来很重要. 变量声明用于说明变量的属性(主要是变量的类型),而变量的定义除此之外还将引起存储器的分配. 如果将下列语句放到外部:
```cpp
int sp;
double val[MAXVAL];
```
那么这两条语句将 *定义* 外部变量sp与val,并为它分配存储单元,同时这两条语句还可以作为该源文件中其余部分的声明. 而下面两行语句:
```cpp
extern int sp;
extern double val[];
```
为源文件的其余部分声明了一个int类型的外部变量sp以及一个数组外部变量double(长度在其他地方确定),但这两个声明并没有建立变量或者为他们分配存储单元.

在一个源程序的所有源文件中,一个外部变量只能在某个文件中定义一次,而其他文件可以通过`extern`声明访问它(定义外部变量的源文件中也可以包含对该外部变量的extern声明).外部变量的定义中必须指定数组的长度,但extern声明不一定要指定数组长度.

外部变量的初始化只能出现在其定义中.

假定函数pop与push定义在一个文件中,val与sp在另一个文件中定义并被初始化(通常不大可能这样组织程序),则需要通过下面这些定义与声明把函数和变量绑定在一起:

file1:
```cpp
extern int sp;
extern double val[];

void push(double f){};

double pop(void){}
```
file 2:
```cpp
int sp = 0;
double val[MAXVAL];
```
由于文件file1 中的extern声明不仅放在定义的外面,而且还放在他们的前面, 因此它们适用于该文件中的所有函数.对于file1,这样一组声明就够了.如果要在同一个文件中先使用,后定义变量sp与val, 也需要按照这种方式组织文件.

## 4.5 头文件
我们对下面两个因素进行了折中:一方面是我们期望每个文件只能访问它完成任务所需的信息;另一方面是现实中维护多个头文件比较困难.
我们可以得出这样的结论: 对于某些中等规模的程序,最好只用一个头文件存放各个程序共享的对象.较大的程序需要更多头文件,我们需要精心组织他们.
- [RPN_calculator](https://github.com/chenboshuo/c_learning/commit/92b4ca3aee38414bb1587c5c5b26021e2f7a5445)
主函数main.c:
```c
#include <stdio.h>
#include <stdlib.h>
#include "calc.h"
#define MAXTOP 100
```
push与pop及外部变量放到stack.c中
```c
#include <stdio.h>
#include "calc.h"
int sp = 0;
double val[MAXVAL];
void push(double) {...}
double pop(void){...}
```
gettop 放到gettop.c中
```c
#include <stdio.h>
#include <ctype.h>
#include "calc.h"
gettop(){}
```
getch,ungetch放到getch.c
```c
#include <stdio.h>
#define BUFSIZE 100
char buf[BUFSIZE];
int bufp = 0;
int getch(void){...}
int ungetch{...}
```
考虑到定义与声明文件的共享问题,我们尽可能把部分集中在一起,这样只需一个副本,改进程序也容易保证正确性.我们把公共头文件放到`calc.h`中
```cpp
#define NUMBER '0'
void push(double);
double pop(void);
int gettop(char [])
int getch(void);
void ungetch(int);
```

## 4.6 静态变量
某些变量,比如stack.c中的sp与val以及getch.c中定义的变量buf与bufp,他们仅供源文件的函数使用,其他函数不能访问.用`stastic`声明限定外部变量与函数,可以将其后声明的对象的作用域限定为被编译源文件的剩余部分.通过`static`限定外部对象,可以达到隐藏外部对象的目的.比如getch-ungetch复合结构需要共享buf和bufp两个变量,这样buf,bufp必须是外部变量,但这两个对象不应该被getch,ungatch函数调用者访问.

要将对象指定为静态存储,可以在对象之前加上关键字`static`作为前缀,其他函数不能访问buf与bufp,因此两个名字不会和同一文件其他相同名字冲突.

-[修改后的文件](https://github.com/chenboshuo/c_learning/commit/3e01a1c98505de603aea416701073ae1b721e267)

外部的static声明通常用于多变量,当然他也可以用于声明函数. 通常情况下,函数名字是全局可访问的,对于整个程序的各个部分都可见. 但是,如果把函数声明为`static`类型,则该函数名除了对函数声明文件可见以外,其他文件都不可以访问.

static也可以声明内部变量.`static`类型的内部变量同自动变量一样,是某个待定函数的局部变量,只能在该函数中使用,但它与自动变量不同的是,不管其所在函数是否被调用,它一直存在,不像自动变量,随着函数的被调用和退出而存在和消失.换句话说,static类型的内部变量只是一种只能在某个特定函数中使用但一直占据内存空间的变量.

## 4.7 寄存器变量
`register`告诉编译器,它声明的变量在程序中只用频率较高. 其思想是,将`register`变量放在机器的寄存器中,这样可以使程序更小,运行更快.但编译器可以忽略此选项.
```cpp
register int x;
register char c;
```
regester声明只适用于自动变量以及函数形式的参数
``` c
f(register unsigned m, register long n){
  register int i;
}
```
实际使用时,底层硬件环境的实际情况对寄存器变量的使用会有些限制.每个函数只有很少的变量可以保存在寄存器中,且只允许某些类型的变量. 但是,过量的寄存器声明并没有什么害处,因为编译器可以忽略过量的或者不支持的寄存器变量声明.另外,无论寄存器变量实际上是否放在寄存器中, *它的地址都是不能访问的*. 在不同机器中,对寄存器变量的数目和类型的具体限制也是不同的.

## 4.8 程序块结构
变量的声明(包括初始化)除了可以紧跟在函数开始的花括号之后,还可以跟在其他标示复合语句开始的左花括号之后.以这种方式声明的变量可以隐藏程序块之外的同名变量,他们之间没有任何关系,并在与左花括号匹配的右花括号之前一直存在.
```cpp
if (n > 0) {
  int i; // 声明一个变量i
  for (size_t i = 0; i < n; i++) {...  }
}
```
变量 i 的作用域是if语句的真分支, 这个i与该程序外声明的i无关.每次进入程序时,在程序块内声明以及初始化的自动变量都被初始化.静态变量只在第一次进入程序块时被初始化一次.

自动变量(包括形式参数)也可以隐藏同名的外部变量与函数.
```cpp
int x;
int y;

f(double x){
  double y;
}
```
在一个好的程序设计风格中,应该避免出现变量名相同的情况,否则,很可能引起混乱和错误

## 4.9 初始化
在不进行显式初始化的情况下,外部变量和静态变量都被初始化为0,自动变量和寄存器变量则没有定义.

定义标量变量时,可以在变量名后面紧跟一个符号或者表达式来初始化变量:
```cpp
int x = 1;
cahr squote = '\'';
long day = 1000L * 60L * 60L * 24h; //每天的毫秒数
```

对于外部变量和静态变量来说,初始化表达式必须是常量表达式,且只初始化一次(从概念上说是程序在在程序开始执行前进行初始化).对于自动变量与寄存器变量, 则在每次进入函数或程序块中被初始化.

对于自动变量与寄存器变量与寄存器变量来说,初始化表达式可以不是常量表达式:表达式中可以不是常量表达式之前已经定义的值, 包括函数调用,我们可以这样修改折半查找的程序.

- [代码修改](https://github.com/chenboshuo/c_learning/commit/63466b91ed7d1acc1ac3129c3754dd464435598d)

实际上,自动变量的初始化等效于赋值语句,究竟用那种形式,取决于个人习惯.

数组初始化可以后面紧跟一个初始化表达式列表, 初始化列表用花括号括起来,各个初始化变量用`,`分隔.
```cpp
int days[] = { 31, 28, 31, 30, 31, 30,31, 31, 30, 31, 30, 31 }
```

如果初始化个数比数组元素少, 没有初始化的元素将被初始化为0.初始化字符比数组元素多,则是错误的. 可以用一个字符串来代替花括号
```cpp
char pattern[] = "ould"
char pattern[] = {'o', 'u', 'l', 'd', '\0'}
```
这种情况下,数组长度为5

## 4.10 递归
C语言当中函数会调用自身.
如果打印十进制数,有两种方式,一个是将每个数字存到数组中,这与`3.6`的`itoa`类似,另一种是利用递归首先打印高位数字,然后再打印后面的数字

[打印十进制数](https://github.com/chenboshuo/c_learning/commit/c6586292b3e2ccda0cc629ed82a537bff76a2d6c)

递归函数调用自身时,每次调用都会得到一个与之前自动变量不同的新的自动变量集合.

另一个说明递归的例子是快速排序.快速排序是C.A.R.Hoare于1962年发明的.

1. 从数列中挑出一个元素，称为 “基准”（pivot）;

2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；当某个子集小于2时,这子数列不需要再次排序,终止递归

![快速排序@五分钟学算法](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaAY3VU8iaziaYcxAasTdrIu69BOVPYtfvqdvicmlJDS94cG2tjwZhVkdHA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

[code](https://github.com/chenboshuo/c_learning/blob/d1c18f779c6d28bffb4892207886f181469804a2/the_c_programming_language/chapter_4_function_and_program_structure/quicksort.cpp)

标准库`stdlib,h`提供了qsort函数,它可用于任意对象排序.[用法](https://github.com/chenboshuo/c_learning/blob/4cc5c1724d478e1a078380b416e27490421996ad/the_c_programming_language/chapter_4_function_and_program_structure/quicksort.cpp)

递归并不节省内存的开销, 因为递归调用过程中必须在某个地方维护一个存储处理值得栈. 递归的执行速度并不快, 但递归代码比较紧凑,比相应的非递归代码更易于编写和理解. 在描述树等递归定义的数据结构尤其方便.
