# 第四章 函数与程序结构

## 4.1 函数的基本知识
最简单的函数如图
```
dunny(){}
```
它不执行操作也没有返回值,可以在开发时候保留位置利于以后填充.
若函数省略了返回值类型,则默认为int型.

程序可以看作变量定义与函数定义的集合.函数之间的通信可以通过参数,函数返回值以及外部变量进行.函数在源文件中出现的次序是任意的.只要保证每一个函数不被分离到多个文件中,源程序就可以分为多个文件.

被调用函数通过return语句向调用者返回值
```c
return 表达式
```
必要时,表达式将被转换为返回值的类型.表达式通常加一对圆括号,此处括号是可选的.

调用函数可以忽略返回值,return后面也不一定需要表达式.return后面没有表达式时,函数不会向调用者返回值.当被调用的函数执行到最右边的花括号时而结束执行时,控制同样会返回给调用者(不返回值).如果某个函数从一个地方返回有返回值,而从另一个地方没有返回值,该函数不非法,但可能是一种文体的征兆.

## 4.2 返回非整型值得函数
- [string_to_double.cpp 字符串转为浮点数](./string_to_double.cpp)
标准库中包含类似atof函数,在头文件`<stdlib.h>`中声明.
- [calculator 简单计算器](calculator.cpp)
```cpp
double sum,atof(char[])
```
函数声明与定义类型必须一致. 如果atof函数与调用它的主函数在同一源文件中,类型不一致,编译器会监测出错误. 但如果是单独编译,不匹配错误不会被检测出来,结果毫无意义.

如果先前没有声明的一个名字出现在表达式中,并且其后紧跟一个左圆括号,那么上下文会认为这是一个函数名字,该函数的返回值被假定为int,但上下文不对参数做任何假设. 并且,如果函数声明不含参数,如:
```cpp
double atof()
```
那么编译程序不会对atof的参数做任何假设, 并会关闭所有参数检查. 对空参数表的这种特殊处理是为了使新的编译器能编译比较古老的c语言程序.不过这是不提倡的,如果带有参数,则要声明他们,如果没有参数,用`void`进行声明.

```cpp
int atoi(char s[]){
  double atof(char s[]);

  return (int) atof(s);
}
```

其中,表达式的值在返回之前被转换为函数类型. 因为函数atoi返回值为int,所以return语句中atof函数的double将被自动转化为int. 但是这种操作可能会丢失信息,某些编译器会给出警告,在这里进行显式转换,可以避免相关警告信息.

## 4.3 外部变量
C语言程序可以看作由一系列外部对象组构成,这些外部对象可以是变量或者函数.internal 用于描述定义在函数内部的函数及变量. 外部变量定义在函数之外,因此可以在许多函数中使用.C语言不允许在一个函数中定义其他函数,因此函数本身是外部的. 默认情况下,外部变量函数有下列性质:
通过一个名字对外部变量的所有引用(即这种引用来自单独编译的不同函数)实际上都是引用的同一对象(标准中把这一性质成为 *外部链接*)

因为外部变量可以在全局内访问,这就为函数之间的数据交换提供了一种可以代替函数参数与返回值的方式. 任何函数都可以通过名字访问同一个外部变量,当然这个变量需要某种方式进行声明.

如果函数之间要共享大量变量,使用外部变量比使用一个很长的参数表方便,但是,这样做必须非常谨慎,因为这种方式可能对程序结构产生不良影响,而且很可能导致各个函数之间有太多数据联系.

外部变量的用途还表现在他们与内部变量相比有更大的作用域和更长的生存期. 自动变量只能在函数的内部使用, 从其所在的函数被调用时变量开始存在, 在函数退出时变量也消失. 外部变量是永远存在的, 他们的值在一次函数调用到下一次函数调用之间保持不变. 因此,如果两个函数必须共享某些数据,而两个函数有不调用对方,这种情况下最方便的方式是将共享数据设为外部变量.

下面通过例子说明这一点
目标是编写一个具有加减乘除运算的计算器程序,为了容易实现,我们用逆波兰表示法(Reverse Polish notation，RPN，或逆波兰记法)来代替中缀表示法.

逆波兰表示法中,所有运算符都在操作数的后面
```
(1-2) * (4+5)
1 2 - 4 5 + *
```
逆波兰表示法中没有括号,只要知道每个运算符需要几个操作数就不会引起歧义.

实现:
每个操作数都被压入栈中;一个运算符到达后,从中弹出相应项目的操作数,然后把该运算符作用于弹出的操作数,并把结果压入栈中.例如上面先把1,2压入栈,然后用两者之差-1取代他们; 然后4,5压入栈中,用9取代他们, 最后取出栈顶的-1,9,把他们的积-9压入栈顶
```cpp
while (下一个是运算符或操作数不是EOF) {
  if (是数) {
    将数压到栈中
  } else if (是运算符) {
    弹出所需数目的操作数
  } else if(是换行符){
    弹出并打印栈顶的值
  }else{
    出错
  }
}
```
main不需要了解控制栈的变量信息,所以可以作为外部变量
- [RPN_calculator 逆波兰计算器](./RPN_calculator.cpp)

## 4.4 作用域原则
构成C语言程序的函数与外部变量可以分开进行编译. 一个程序可以存放在几个文件中,原先已编译过的函数可以从库中进行加载.

名字的 *作用域* 指的是程序中可以使用该名字的部分.对于函数开头声明的自动变量,其作用域是声明该变量名的函数. 不同函数中声明具有相同名字的各个局部变量之间没有任何关系. 函数的参数也是这样,实际上可以看成局部变量.

外部变量或函数的作用域从声明它的地方开始,到其所在的(等待编译)文件的末尾结束..
```cpp

main(){}

int sp = 0;
double val[MAXVAL];

void push(double f){}

double pop(void){}
```
例如,`push`不需要任何声明就可以通过名字访问变量`sp`,`val`但是变量名不能用在主函数`main`中.

另一方面,如果在外部变量声明之前使用该变量, 或者外部变量的定义与使用不在同一源文件中,则必须在相应的变量声明中强制使用关键字`extern`

将外部变量的 *声明* 和 *定义* 严格区分开来很重要. 变量声明用于说明变量的属性(主要是变量的类型),而变量的定义除此之外还将引起存储器的分配. 如果将下列语句放到外部:
```cpp
int sp;
double val[MAXVAL];
```
那么这两条语句将 *定义* 外部变量sp与val,并为它分配存储单元,同时这两条语句还可以作为该源文件中其余部分的声明. 而下面两行语句:
```cpp
extern int sp;
extern double val[];
```
为源文件的其余部分声明了一个int类型的外部变量sp以及一个数组外部变量double(长度在其他地方确定),但这两个声明并没有建立变量或者为他们分配存储单元.

在一个源程序的所有源文件中,一个外部变量只能在某个文件中定义一次,而其他文件可以通过`extern`声明访问它(定义外部变量的源文件中也可以包含对该外部变量的extern声明).外部变量的定义中必须指定数组的长度,但extern声明不一定要指定数组长度.

外部变量的初始化只能出现在其定义中.

假定函数pop与push定义在一个文件中,val与sp在另一个文件中定义并被初始化(通常不大可能这样组织程序),则需要通过下面这些定义与声明把函数和变量绑定在一起:

file1:
```cpp
extern int sp;
extern double val[];

void push(double f){};

double pop(void){}
```
file 2:
```cpp
int sp = 0;
double val[MAXVAL];
```
由于文件file1 中的extern声明不仅放在定义的外面,而且还放在他们的前面, 因此它们适用于该文件中的所有函数.对于file1,这样一组声明就够了.如果要在同一个文件中先使用,后定义变量sp与val, 也需要按照这种方式组织文件.
