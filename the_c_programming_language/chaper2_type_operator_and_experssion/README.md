# chaper 2 type operator and experssion
# 类型,运算符与表达式
## 2.1 变量名
名字是由字母和数字组成的序列,第一个字符必须是字母. 下划线`_`也被看作字母, 由于库例程序是下划线开头, 所以变量名不要以`_`开头.大写字母与小写字母有区别,变量名一般用小写字母,常量用大写字母

局部变量一般名字较短,外部变量一般名字很长
## 2.2 数据类型及长度

| 类型 |  |
| :------------- | :------------- |
| char | 字符型,占用一个字节,可以存本地字符集的一个字符 |
|int|整型,通常反映机器中整数的最自然长度|
|float|单精度浮点数|
|double|双精度浮点数|

此外,还可以加上一些限定符来限制整形
```c
short int sh;
long int ss;
```
这种类型声明中,int可以省略.

short与long限定符的引入可以为我们提供满足实际需要的整型数.int通常代表特定机器中整数的自然长度,**`short`类型通常为16位; `long`通常为32位**,int可以是16位或32位.各个编译器可以根据硬件特性自主选择合适长度,遵循如下限制:**`short`与`int`至少16位,`long`类型至少32位,`short`不得长于`int`,`int`不得长于`long`**

类型限定符`signed`与`unsigned`可以用于限定`char`或者任何整型,`unsigned`是非负数,并遵守算数模2^n定律,其中n为该类型占有的位数.例如,char用8位,那么`unsigned char`取值范围0~255,而`signed char`取值范围-128~127(在采用对二补码的机器上)

`long double`表示高精度浮点数,其长度也取决于具体的实现.

## 2.3 常量

类似于`1234`的整数类型属于`int`,`long`类型以l或L结尾,如`123456789L`,如果一个整数太大无法用`int`表示时,也被当作`long`处理,无符号以u或者U结尾,ul或UL后缀表示`unsigned long`

浮点数通常包含一个小数点(`123.4`)或者一个指数(`1e-2`),也可以两者都有.没有后缀的浮点数为`double`,后缀`f`或`F`表示`float`;后缀`l`或`L`表示`long double`

整型也可以用八进制或者十六进制表示.带前缀0的为八进制,前缀为`0x`或`0X`的为16进制,如十进制的31可以写为`037`或者`0x1f`或`0X1F`. 八进制与十六进制也可以用`L`表示`long`,用`U`表示`unsigned`,例如`0XFUL`为十进制的15.

### 字符常量
一个 *字符常量* 是一个整数,书写时括到单引号中,如`'x'`.

某些字符可以通过`\`转义字符序列表示为字符和字符串常量,我们可以用`'\ooo'`表示任意字节大小的位模式`ooo`代表1~3个八进制数字,也可以用`'\xhh'`,其中`hh`表示一个或者多个十六进制数字,因此可以书写

```c
#define VTAB '\013' // ASCII纵向制表符
#define BELL '\007'
```

十六进制写为
```c
#define VTAB '\xb' // ASCII纵向制表符
#define BELL '\x7'
```

| 转义符 | 含义 |转义符|转义符
| :--- | :- |:-|:-|
| `\a` | 响铃符 |`\\`|反斜杠|
|`\b`|回退符|`\f`|换页符
|`\'`|单引号|`\"`|双引号|
|`\n`|换行符|`\r`|回车符(清空这一行内容)
|`\t`|横向制表符|`\v`|纵向制表符
|`\ooo`|八进制数|`\xhh`|十六进制数
|`\?`|问号|`\0`|值为0的字符,空字符(null)

有时用'\0'代替0,强调某些字符属性,但其值为0

**常量表达式** 是只包含常量的表达式,这种表达式在编译时求值,不在运行时求值.
### 字符串常量
**字符串常量** 也叫 *字符串面值* 双引号不是字符串的一部分,编译时会将多个字符串链接起来,如`"hello""world"`等价于`hello world`.字符串的链接为较长字符串分散在若干个源文件提供支持.

从技术角度看,字符串就是字符数组,字符串内部使用`'\0'`作为字符串的结尾.因此,存储字符串的物理单元数比双引号中的字符多一个,也说明c对字符串的长度没有限制,但必须扫描完字符串之后才知道长度,标准库函数中`strlen(s)`可以返回字符串的长度,标准头文件`<string.h>`声明dtrlen和其他字符串函数.

### 枚举常量

枚举是一个常量整值型的列表
```c
enum boolean {NO, YES};
```
在没有显示说明情况下,enum的第一个枚举名的值为0,第二个为1,依此类推.如果只指定部分枚举名的值,未指定的枚举名的值依着最后一个指定值向后递增
```c
enum months {JAN = 1,FEB, MAR, APR, MAY, JUN, JUL,AUG,SEP, OCT, NOV, DEC};
```
枚举为建立常量值与名字之间关联提供了一种便利的方式.相对于`#define`语句来说,其优势在于常量值可以自动生成,尽管可以声明`enum`类型变量,但编译器不检查这种类型存储值是否为枚举变量的有效值. 不过,枚举变量提供这种检查,枚举比`#define`更有优势,此外,调试程序可以以符号形式打印枚举变量的值.

## 2.4 声明
所有变量先声明,后使用如
```c
int a,b,c[100];
int f;// z这样声明利于加注释
char lower;
int i = 0;// 也可以赋值
const double e=2.718;// const 限定变量不可以被修改,也可以配合数组参数使用
```

## 2.5 算术运算符
二元运算符`+`,`-`具有相同优先级,比`*`,`/`,`%`低,`*`,`/`,`%`又比一元运算符`+`,`-`低

## 2.6 关系运算与逻辑运算
`>`,`>=`,`<`, `<=`具有相同优先级,仅次于相等性运算符`==`,`!=`

关系运算符比算术运算优先级低

运算符`&&`比`||`优先级高,但两者都比相比行运算符低

## 2.7 类型转换
字符串转化为对应整型数

[char_to_int](./char_to_int.cpp)

转化为小写
```c
int lower(int c)
{
  if (c >= 'A' && c <='Z')
    return c + 'a' - 'A';
  else
    return c;
}
```

上述函数是为ASCII设计的,在ASCII中大写字母与小写字母的数字值有固定间隔,每个字母都是连续的. 后一点对EBCDIC字符集不成立,所以可以用`ctype.h`的函数`isdigit(c)`

将字符类型转换成整型时注意一点,C语言没有指定char类型的变量是无符号还是带符号的变量,有可能在某些些机器上int结果为负.在某些机器中,char最左一位是1,则转化为负数(进行`符号扩展`);另一些机器,char转换时左边加0.

当关系表达式结果为真时值为1,否则是0
```c
d = c >= '0' && c <='9'
```
c为数字时,d=1,否则d=0

c语言在运算时,很多情况下会进行隐式算术类型转换. 一般来说,计算时把"较低"类型转化为"较高"类型,但是`float`不会自动转化成`double`

赋值时右边的类型也被转化为左边的类型

无论是否进行符号扩展,字符型变量都会变成整型变量

强制类型转换
```
(类型名) 表达式
```
标准库中伪随机数发生器就用了类型转换
```c
unsigned long int next = 1;

/* rand函数,返回0~32767的伪随机数 */
int rand(void){
  next = next * 1103515245 + 12345;
  return (unsigned int)(next/66535) % 32768
}
/* srand:为rand()设置种子数 */
void strand(unsigned int seed) {
  next = seed;
}
```

## 2.8 自增运算与自减运算符
表达式`n++`是先试用变量n的值n在+1,`++n`是先+1,再使用n的值

自增与自减只能用于变量`(i+j)++`是非法的
```c
s[i] = c;
i++
```
可以写成
```c
s[i++] = c;
```
